<script lang="ts">
  import { createEventDispatcher, onMount } from 'svelte';
  import { settings } from './stores/settings';

  export let isGenerating = false;
  export let isTauriAvailable = false;
  export let getGpuInfo: (() => Promise<any>) | null = null;
  export let unloadModels: (() => Promise<any>) | null = null;
  export let listVariables: (() => Promise<any>) | null = null;
  export let openSettings: (() => void) | null = null;

  const dispatch = createEventDispatcher();

  let input = '';
  type HistoryItem =
  | { type: 'input' | 'output' | 'error' | 'info' | 'success' | 'dim' | 'cyan' | 'magenta' | 'progress-msg'; text: string }
  | { type: 'table'; rows: Array<{ cmd: string; desc: string }> }
  | { type: 'varsTable'; rows: Array<{ id: string; count: number; sample: string }> }
  | { type: 'header'; text: string }
  | { type: 'divider' }
  | { type: 'progress-bar'; percent: number; stage: string }
  | { type: 'prompt-highlight'; variant: 'enhanced' | 'final'; text: string };

  let history: HistoryItem[] = [];
  let suggestions: string[] = [];
  let showSuggestions = false;
  let selectedSuggestion = -1;
  let inputEl: HTMLInputElement;
  let historyEl: HTMLDivElement;

  // Progress state
  let currentProgress = 0;
  let currentStage = '';
  let progressBarIndex = -1;  // Track where our progress bar is in history

  // State
  let currentSeed: number | null = null;
  let currentSize = { width: 1024, height: 1024 };

  // Dynamic prompt variables (loaded from backend)
  let promptVars: string[] = [];

  // Version and config - will be updated from backend
  let VERSION = '0.4.1';
  let modelConfig = { image_model: 'Z-Image-Turbo', image_mode: 'loading...', llm_model: 'Qwen3-4B', llm_mode: 'loading...' };
  const commands = ['/help', '/vars', '/enhance', '/seed', '/size', '/gpu', '/unload', '/settings', '/version', '/changelog', '/quit', '/q'];

  // Tips state - collapsible, initialized from settings store
  let tipsExpanded = $settings.cli.showTipsOnStart;

  // Tutorial state - collapsible, initialized from settings store
  let tutorialExpanded = $settings.cli.showTutorialOnStart;
  
  // Function to fetch version and config from backend
  export async function fetchVersion(apiBase: string) {
    try {
      // Fetch health for version
      const healthRes = await fetch(`${apiBase}/api/health`, { signal: AbortSignal.timeout(2000) });
      if (healthRes.ok) {
        const data = await healthRes.json();
        if (data.version) {
          VERSION = data.version;
        }
      }
      
      // Fetch model config
      const configRes = await fetch(`${apiBase}/api/config`, { signal: AbortSignal.timeout(2000) });
      if (configRes.ok) {
        const config = await configRes.json();
        modelConfig = config;
        // Update the config line in history
        history = history.map(item => {
          if (item.type === 'info' && item.text.includes('Image:')) {
            return { ...item, text: `üé® Image: ${config.image_model} (${config.image_mode})  ‚Ä¢  ü§ñ LLM: ${config.llm_model} (${config.llm_mode})` };
          }
          return item;
        });
      }
    } catch (e) {
      // Ignore - keep defaults
    }
  }

  async function loadVariables() {
    console.log('üìö [FakeCLI] Loading variables...');
    if (listVariables) {
      try {
        const result = await listVariables();
        console.log('üìö [FakeCLI] Variables result:', result);
        if (result?.success && result.variables) {
          promptVars = result.variables.map((v: any) => v.id);
          console.log('‚úÖ [FakeCLI] Loaded variables for autocomplete:', promptVars);
        } else {
          console.warn('‚ö†Ô∏è [FakeCLI] No variables returned');
        }
      } catch (e) {
        console.error('‚ùå [FakeCLI] Could not load variables:', e);
      }
    } else {
      console.warn('‚ö†Ô∏è [FakeCLI] listVariables prop not provided');
    }
  }

  onMount(async () => {
    // Welcome message - show model config, not version (tips are rendered separately)
    history = [
      { type: 'info', text: `üé® Image: ${modelConfig.image_model} (${modelConfig.image_mode})  ‚Ä¢  ü§ñ LLM: ${modelConfig.llm_model} (${modelConfig.llm_mode})` },
      { type: 'success', text: '‚úì All dependencies available' },
    ];

    // Load variables dynamically
    await loadVariables();

    // Focus input
    inputEl?.focus();
  });

  // Toggle tips visibility
  function toggleTips() {
    tipsExpanded = !tipsExpanded;
  }

  // Toggle tutorial visibility
  function toggleTutorial() {
    tutorialExpanded = !tutorialExpanded;
  }

  // Tips content (rendered separately, not in history)
  const tipsList = [
    '‚Ä¢ Use __variable__ syntax for random substitution (e.g., __animal__)',
    '‚Ä¢ Missing variables are auto-generated by the local LLM',
    '‚Ä¢ Add \'>\' to enhance prompt (e.g., \'a cat > make it magical\')',
    '‚Ä¢ Add batch params with \':\' (e.g., \'prompt : x10,h832,w1216\')',
  ];

  // Tutorial content (placeholder for future guide)
  const tutorialContent = 'Welcome to Z-Explorer! This tutorial will guide you through the app. (Coming soon...)';

  function updateSuggestions() {
    const cursorPos = inputEl?.selectionStart || 0;
    const textBeforeCursor = input.slice(0, cursorPos);

    // Command suggestions
    if (textBeforeCursor.includes('/')) {
      const lastSlash = textBeforeCursor.lastIndexOf('/');
      const partial = textBeforeCursor.slice(lastSlash);
      suggestions = commands.filter(cmd => cmd.startsWith(partial) && cmd !== partial);
      showSuggestions = suggestions.length > 0;
      console.log(`üîç [Autocomplete] Command suggestions for "${partial}":`, suggestions);
      return;
    }

    // Variable suggestions
    if (textBeforeCursor.includes('__')) {
      const lastVar = textBeforeCursor.lastIndexOf('__');
      const afterVar = textBeforeCursor.slice(lastVar);
      console.log(`üîç [Autocomplete] Looking for variables matching "${afterVar}"`);
      console.log(`üîç [Autocomplete] Available promptVars:`, promptVars);
      if ((afterVar.match(/__/g) || []).length === 1) {
        suggestions = promptVars.filter(v => v.startsWith(afterVar) && v !== afterVar);
        showSuggestions = suggestions.length > 0;
        console.log(`üîç [Autocomplete] Variable suggestions:`, suggestions);
        return;
      }
    }

    showSuggestions = false;
    suggestions = [];
  }

  function applySuggestion(suggestion: string) {
    const cursorPos = inputEl?.selectionStart || 0;
    const textBeforeCursor = input.slice(0, cursorPos);

    if (textBeforeCursor.includes('/')) {
      const lastSlash = textBeforeCursor.lastIndexOf('/');
      input = input.slice(0, lastSlash) + suggestion + input.slice(cursorPos);
    } else if (textBeforeCursor.includes('__')) {
      const lastVar = textBeforeCursor.lastIndexOf('__');
      const afterVar = textBeforeCursor.slice(lastVar);
      input = input.slice(0, lastVar) + suggestion + input.slice(cursorPos);
    }

    showSuggestions = false;
    selectedSuggestion = -1;
    inputEl?.focus();
  }

  function handleKeydown(e: KeyboardEvent) {
    if (showSuggestions) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedSuggestion = Math.min(selectedSuggestion + 1, suggestions.length - 1);
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
        return;
      }
      if (e.key === 'Tab' || e.key === 'Enter') {
        if (selectedSuggestion >= 0) {
          e.preventDefault();
          applySuggestion(suggestions[selectedSuggestion]);
          return;
        }
      }
      if (e.key === 'Escape') {
        showSuggestions = false;
        return;
      }
    }

    if (e.key === 'Enter' && !showSuggestions) {
      submit();
    }
  }

  function parseParams(input: string): { prompt: string; params: any } {
    const params = { count: 1, width: 1024, height: 1024 };

    if (!input.includes(':')) {
      return { prompt: input, params };
    }

    const parts = input.split(':');
    const paramPart = parts[parts.length - 1].trim();

    // Check if it looks like parameters
    if (!/[xhw]\d/.test(paramPart)) {
      return { prompt: input, params };
    }

    const prompt = parts.slice(0, -1).join(':').trim();

    for (const param of paramPart.split(',')) {
      const p = param.trim().toLowerCase();
      if (p.startsWith('x')) params.count = parseInt(p.slice(1)) || 1;
      if (p.startsWith('h')) params.height = parseInt(p.slice(1)) || 1024;
      if (p.startsWith('w')) params.width = parseInt(p.slice(1)) || 1024;
    }

    return { prompt, params };
  }

  function submit() {
    if (!input.trim() || isGenerating) return;

    const trimmed = input.trim();

    // Handle commands
    if (trimmed.startsWith('/')) {
      handleCommand(trimmed);
      input = '';
      return;
    }

    // Parse prompt and parameters
    const { prompt, params } = parseParams(trimmed);

    history = [...history, { type: 'input', text: `>>> ${trimmed}` }];

    if (params.count > 1 || params.width !== 1024 || params.height !== 1024) {
      history = [...history, {
        type: 'info',
        text: `üìê Batch: ${params.count} image(s) @ ${params.width}√ó${params.height}`
      }];
    }

    // Dispatch to parent - progress messages will come from backend events
    dispatch('generate', { prompt, params, seed: currentSeed });

    // Reset seed after use (like pyros-local)
    currentSeed = null;

    // Keep prompt for iteration
    scrollToBottom();
  }

  function handleCommand(cmd: string) {
    history = [...history, { type: 'input', text: `>>> ${cmd}` }];

    const [command, ...args] = cmd.split(' ');

    switch (command) {
      case '/help':
        history = [...history,
          { type: 'header', text: 'üìñ Commands' },
          { type: 'table', rows: [
            { cmd: '/help', desc: 'Show this help' },
            { cmd: '/vars', desc: 'List available prompt variables' },
            { cmd: '/enhance <prompt>', desc: 'Enhance a prompt without generating' },
            { cmd: '/seed <number>', desc: 'Set seed for next generation' },
            { cmd: '/size <WxH>', desc: 'Set output size (e.g., 1024x1024)' },
            { cmd: '/gpu', desc: 'Show GPU memory status' },
            { cmd: '/unload', desc: 'Unload models to free GPU memory' },
            { cmd: '/settings', desc: 'Open settings dialog' },
            { cmd: '/version', desc: 'Show version information' },
            { cmd: '/changelog', desc: 'Show recent changes' },
            { cmd: '/quit or /q', desc: 'Exit' },
          ]},
          { type: 'divider' },
          { type: 'cyan', text: 'üí° Tips:' },
          { type: 'dim', text: '‚Ä¢ Use __variable__ syntax for random substitution (e.g., __animal__)' },
          { type: 'dim', text: '‚Ä¢ Missing variables are auto-generated by the local LLM' },
          { type: 'dim', text: '‚Ä¢ Add \'>\' to enhance prompt (e.g., \'a cat > make it magical\')' },
          { type: 'dim', text: '‚Ä¢ Add batch params with \':\' (e.g., \'prompt : x10,h832,w1216\')' },
          { type: 'dim', text: '  x<N>=count, h<N>=height, w<N>=width (all optional)' },
        ];
        break;
      case '/vars':
        if (listVariables) {
          history = [...history, { type: 'cyan', text: 'üìã Loading variables...' }];
          scrollToBottom();

          listVariables().then((result: any) => {
            if (result?.success && result.variables) {
              const varRows = result.variables.map((v: any) => ({
                id: v.id,
                count: v.count,
                sample: v.sample?.slice(0, 3).join(', ') || ''
              }));
              history = [...history,
                { type: 'header', text: `üìã ${result.count} Variables Available` },
                { type: 'varsTable', rows: varRows },
              ];
              // Update autocomplete
              promptVars = result.variables.map((v: any) => v.id);
            } else {
              history = [...history, { type: 'error', text: '‚ùå Failed to load variables' }];
            }
            scrollToBottom();
          });
        } else {
          history = [...history,
            { type: 'header', text: 'üìã Available Variables' },
            { type: 'divider' },
            ...promptVars.map(v => ({ type: 'magenta' as const, text: `  ${v}` }))
          ];
        }
        break;
      case '/enhance':
        if (args.length > 0) {
          history = [...history,
            { type: 'cyan', text: 'ü§ñ Enhancing prompt with local LLM...' },
            { type: 'dim', text: '(Enhancement will be applied during generation)' },
          ];
        } else {
          history = [...history,
            { type: 'error', text: '‚ùå Usage: /enhance <prompt>' },
          ];
        }
        break;
      case '/seed':
        if (args.length > 0) {
          const seedVal = parseInt(args[0]);
          if (!isNaN(seedVal) && seedVal >= 0) {
            currentSeed = seedVal;
            history = [...history,
              { type: 'success', text: `‚úì Seed set to: ${seedVal}` },
              { type: 'dim', text: '(Will be used for next generation, then reset)' },
            ];
          } else {
            history = [...history,
              { type: 'error', text: '‚ùå Invalid seed (must be a positive number)' },
            ];
          }
        } else {
          currentSeed = null;
          history = [...history,
            { type: 'cyan', text: 'üé≤ Seed reset to random' },
          ];
        }
        break;
      case '/size':
        if (args.length > 0) {
          const sizeMatch = args[0].toLowerCase().match(/(\d+)x(\d+)/);
          if (sizeMatch) {
            history = [...history,
              { type: 'success', text: `‚úì Size set to: ${sizeMatch[1]}√ó${sizeMatch[2]}` },
            ];
          } else {
            history = [...history,
              { type: 'error', text: '‚ùå Invalid size format. Use: /size 1024x1024' },
            ];
          }
        } else {
          history = [...history,
            { type: 'cyan', text: 'üìê Current size: 1024√ó1024' },
          ];
        }
        break;
      case '/gpu':
        if (getGpuInfo) {
          history = [...history, { type: 'cyan', text: 'üñ•Ô∏è Fetching GPU info...' }];
          scrollToBottom();

          getGpuInfo().then((info: any) => {
            if (info?.available) {
              history = [...history,
                { type: 'header', text: 'üñ•Ô∏è GPU Memory Status' },
                { type: 'success', text: `Device: ${info.device_name}` },
                { type: 'info', text: `Allocated: ${info.allocated_gb} GB` },
                { type: 'info', text: `Reserved: ${info.reserved_gb} GB` },
                { type: 'info', text: `Total: ${info.total_gb} GB` },
                { type: 'cyan', text: `Free: ${info.free_gb} GB` },
              ];
            } else {
              history = [...history,
                { type: 'error', text: `‚ùå ${info?.error || 'GPU not available'}` },
              ];
            }
            scrollToBottom();
          });
        } else {
          history = [...history,
            { type: 'dim', text: '(GPU info not available in demo mode)' },
          ];
        }
        break;
      case '/unload':
        if (unloadModels) {
          history = [...history, { type: 'cyan', text: 'üîÑ Unloading models...' }];
          scrollToBottom();

          unloadModels().then((result: any) => {
            if (result?.success) {
              const unloaded = [];
              if (result.llm_unloaded) unloaded.push('LLM (Qwen3-4B)');
              if (result.image_model_unloaded) unloaded.push('Image model (Z-Image-Turbo)');
              if (result.cuda_cache_cleared) unloaded.push('CUDA cache');

              if (unloaded.length > 0) {
                history = [...history,
                  { type: 'success', text: '‚úì Models unloaded successfully' },
                  { type: 'dim', text: `Unloaded: ${unloaded.join(', ')}` },
                  { type: 'dim', text: '(Models will reload on next generation)' },
                ];
              } else {
                history = [...history,
                  { type: 'info', text: '‚ÑπÔ∏è No models were loaded' },
                ];
              }
            } else {
              history = [...history,
                { type: 'error', text: '‚ùå Failed to unload models' },
              ];
            }
            scrollToBottom();
          });
        } else {
          history = [...history,
            { type: 'dim', text: '(Unload not available in demo mode)' },
          ];
        }
        break;
      case '/version':
        history = [...history,
          { type: 'header', text: `‚ö° Z-Explorer v${VERSION}` },
          { type: 'dim', text: 'AI Image Generation Without the UI Tax' },
          { type: 'info', text: 'Z-Image-Turbo + Qwen3-4B' },
          { type: 'divider' },
          { type: 'dim', text: 'GitHub: github.com/pyros-projects/z-Explorer' },
        ];
        break;
      case '/changelog':
        history = [...history,
          { type: 'header', text: 'üìã Changelog' },
          { type: 'cyan', text: `v${VERSION} - Desktop GUI Integration` },
          { type: 'divider' },
          { type: 'success', text: '‚ú® Added:' },
          { type: 'dim', text: '‚Ä¢ Native desktop app via Tauri with bundled uv binary' },
          { type: 'dim', text: '‚Ä¢ Three modes: GUI (default), CLI (--cli), Server (--server)' },
          { type: 'dim', text: '‚Ä¢ Progress streaming via Server-Sent Events (SSE)' },
          { type: 'dim', text: '‚Ä¢ Masonry gallery layout for generated images' },
          { type: 'dim', text: '‚Ä¢ Prompt saved alongside images as .txt files' },
          { type: 'dim', text: '‚Ä¢ Variable autocomplete in CLI-style input' },
          { type: 'dim', text: '‚Ä¢ /changelog and /version commands' },
          { type: 'divider' },
          { type: 'info', text: 'üîÑ Changed:' },
          { type: 'dim', text: '‚Ä¢ Default mode is now GUI (previously CLI-only)' },
          { type: 'dim', text: '‚Ä¢ Server port standardized to 8345' },
          { type: 'divider' },
          { type: 'dim', text: 'Full changelog: github.com/pyros-projects/z-Explorer/blob/main/CHANGELOG.md' },
        ];
        break;
      case '/settings':
        if (openSettings) {
          history = [...history,
            { type: 'cyan', text: '‚öôÔ∏è Opening settings...' },
          ];
          openSettings();
        } else {
          history = [...history,
            { type: 'dim', text: '(Settings not available in this mode)' },
          ];
        }
        break;
      case '/quit':
      case '/q':
        history = [...history,
          { type: 'cyan', text: 'üëã Goodbye! (Close the window to exit)' },
        ];
        break;
      default:
        history = [...history,
          { type: 'error', text: `‚ùå Unknown command: ${command}` },
          { type: 'dim', text: 'Type /help for available commands' },
        ];
    }

    scrollToBottom();
  }

  function scrollToBottom() {
    setTimeout(() => {
      if (historyEl) {
        historyEl.scrollTop = historyEl.scrollHeight;
      }
    }, 10);
  }

  // Add generated result to history
  export function addResult(text: string, isError = false) {
    history = [...history, { type: isError ? 'error' : 'output', text }];
    scrollToBottom();
  }

  // Stage icons for progress messages
  const stageIcons: Record<string, string> = {
    'starting': 'üöÄ',
    'loading_vars': 'üìã',
    'substituting': 'üîÑ',
    'var_missing': '‚ö†Ô∏è',
    'var_generating': 'ü§ñ',
    'var_saved': 'üíæ',
    'enhancing': '‚ú®',
    'enhanced': 'üí°',
    'phase1_complete': 'üìù',
    'final_prompt': 'üìú',
    'llm_unloaded': 'üßπ',
    'loading_image_model': 'üé®',
    'generating_image': 'üñºÔ∏è',
    'diffusion_step': '‚ö°',
    'generating_steps': '‚ö°',
    'image_saved': 'üíæ',
    'complete': '‚úÖ',
    'error': '‚ùå',
  };
  
  // Stages that shouldn't spam the log (just update progress bar)
  const silentStages = new Set(['diffusion_step', 'generating_steps']);

  // Start a new generation session - adds initial progress bar
  export function startGeneration() {
    console.log('üé¨ [FakeCLI] startGeneration() called');
    currentProgress = 0;
    currentStage = 'starting';
    progressBarIndex = history.length;
    history = [...history, { type: 'progress-bar', percent: 0, stage: 'starting' }];
    console.log('üìä [FakeCLI] Progress bar added at index:', progressBarIndex);
    scrollToBottom();
  }

  // Update progress during generation - updates bar AND adds message
  export function updateProgress(percent: number, stage: string, message: string) {
    console.log(`üìà [FakeCLI] updateProgress(${percent}%, ${stage}, "${message}")`);
    currentProgress = percent;
    currentStage = stage;
    
    // Update the progress bar in place
    if (progressBarIndex >= 0 && progressBarIndex < history.length) {
      history[progressBarIndex] = { type: 'progress-bar', percent, stage };
      history = [...history]; // Trigger Svelte reactivity
      console.log(`üìä [FakeCLI] Progress bar updated: ${percent}% - ${stage}`);
    } else {
      console.warn('‚ö†Ô∏è [FakeCLI] Progress bar index invalid:', progressBarIndex);
    }
    
    // Add the message below the progress bar (if meaningful and not a silent stage)
    // Silent stages (like diffusion_step) only update the bar, don't spam the log
    if (message && !silentStages.has(stage)) {
      const icon = stageIcons[stage] || '‚ö°';
      
      // Special handling for final prompt - highlight it!
      // Skip 'enhanced' stage entirely (redundant with final_prompt)
      if (stage === 'enhanced') {
        // Don't show enhanced prompt box - final_prompt will show the result
        console.log(`üí° [FakeCLI] Skipping enhanced prompt display (will show in final)`);
      } else if (stage === 'final_prompt') {
        history = [...history, { type: 'prompt-highlight', variant: 'final', text: message }];
        console.log(`üìú [FakeCLI] Added final prompt: ${message.substring(0, 50)}...`);
      } else {
        history = [...history, { type: 'progress-msg', text: `${icon} ${message}` }];
        console.log(`üí¨ [FakeCLI] Added progress message: ${icon} ${message}`);
      }
    } else if (silentStages.has(stage)) {
      console.log(`üîá [FakeCLI] Silent stage, only updating bar: ${stage}`);
    }
    
    scrollToBottom();
  }

  // Finalize progress bar - marks it as complete and keeps it in history
  export function completeGeneration(success: boolean) {
    console.log(`üèÅ [FakeCLI] completeGeneration(success=${success})`);
    // Update progress bar to final state
    if (progressBarIndex >= 0 && progressBarIndex < history.length) {
      history[progressBarIndex] = { 
        type: 'progress-bar', 
        percent: 100, 
        stage: success ? 'complete' : 'error' 
      };
      history = [...history];
      console.log('‚úÖ [FakeCLI] Progress bar set to complete');
    }
    
    // Reset tracking but keep the bar in history
    progressBarIndex = -1;
    currentProgress = 0;
    currentStage = '';
    scrollToBottom();
  }

  // Legacy function for backwards compatibility
  export function clearProgress() {
    completeGeneration(true);
  }

  // Computed property for active progress bar (properly typed)
  $: activeProgressBar = (() => {
    if (progressBarIndex >= 0 && progressBarIndex < history.length) {
      const item = history[progressBarIndex];
      if (item.type === 'progress-bar') {
        return item;
      }
    }
    return null;
  })();

  // Font size mapping
  const fontSizeMap: Record<string, string> = {
    small: '11px',
    medium: '13px',
    large: '15px',
  };

  // Reactive font size from settings
  $: currentFontSize = fontSizeMap[$settings.cli.fontSize] || '13px';
</script>

<div class="cli" style="font-size: {currentFontSize}">
  <div class="history" bind:this={historyEl}>
    <!-- Tutorial Section (at top) -->
    {#if $settings.cli.showTutorialOnStart || tutorialExpanded}
      <div class="tutorial-section">
        <button
          class="tutorial-toggle"
          data-testid="tutorial-toggle"
          on:click={toggleTutorial}
          aria-expanded={tutorialExpanded}
        >
          <span class="toggle-icon">{tutorialExpanded ? '‚ñº' : '‚ñ∂'}</span>
          <span class="tutorial-label">üìö Tutorial:</span>
        </button>
        {#if tutorialExpanded}
          <div class="tutorial-content">
            <div class="line dim">{tutorialContent}</div>
          </div>
        {/if}
      </div>
    {/if}

    <!-- Tips Section (at top, after tutorial) -->
    {#if $settings.cli.showTipsOnStart || tipsExpanded}
      <div class="tips-section">
        <button
          class="tips-toggle"
          data-testid="tips-toggle"
          on:click={toggleTips}
          aria-expanded={tipsExpanded}
        >
          <span class="toggle-icon">{tipsExpanded ? '‚ñº' : '‚ñ∂'}</span>
          <span class="tips-label">üí° Tips:</span>
        </button>
        {#if tipsExpanded}
          <div class="tips-content">
            {#each tipsList as tip}
              <div class="line dim">{tip}</div>
            {/each}
          </div>
        {/if}
      </div>
    {/if}

    {#each history as line, i}
      {#if line.type === 'table'}
        <div class="cmd-table">
          {#each line.rows as row}
            <div class="cmd-row">
              <span class="cmd-name">{row.cmd}</span>
              <span class="cmd-desc">{row.desc}</span>
            </div>
          {/each}
        </div>
      {:else if line.type === 'varsTable'}
        <div class="vars-table">
          {#each line.rows as row}
            <div class="var-row">
              <span class="var-id">{row.id}</span>
              <span class="var-count">({row.count})</span>
              <span class="var-sample">{row.sample}</span>
            </div>
          {/each}
        </div>
      {:else if line.type === 'header'}
        <div class="line header">{line.text}</div>
      {:else if line.type === 'divider'}
        <div class="divider"></div>
      {:else if line.type === 'progress-bar'}
        <!-- Skip active progress bar in history - it's rendered separately below -->
        {#if i !== progressBarIndex}
          <div class="progress-container">
            <div class="progress-header">
              <span class="progress-stage">{line.stage.replace(/_/g, ' ')}</span>
              <span class="progress-percent">{line.percent}%</span>
            </div>
            <div class="progress-track">
              <div class="progress-fill" style="width: {line.percent}%">
                <div class="progress-glow"></div>
              </div>
            </div>
          </div>
        {/if}
      {:else if line.type === 'progress-msg'}
        <div class="line progress-msg">{line.text}</div>
      {:else if line.type === 'prompt-highlight'}
        <div class="prompt-highlight {line.variant}">
          <span class="prompt-label">
            {#if line.variant === 'enhanced'}
              üí° Enhanced Prompt
            {:else}
              üìú Final Prompt
            {/if}
          </span>
          <div class="prompt-text">{line.text}</div>
        </div>
      {:else}
        <div class="line {line.type}">{line.text}</div>
      {/if}
    {/each}
  </div>

  <!-- Active progress bar - fixed at bottom above input -->
  {#if activeProgressBar}
    <div class="active-progress">
      <div class="progress-container">
        <div class="progress-header">
          <span class="progress-stage">{activeProgressBar.stage.replace(/_/g, ' ')}</span>
          <span class="progress-percent">{activeProgressBar.percent}%</span>
        </div>
        <div class="progress-track">
          <div class="progress-fill" style="width: {activeProgressBar.percent}%">
            <div class="progress-glow"></div>
          </div>
        </div>
      </div>
    </div>
  {/if}

  <div class="input-area">
    <div class="input-line">
      <span class="prompt-symbol">‚ùØ‚ùØ‚ùØ</span>
      <input
        bind:this={inputEl}
        bind:value={input}
        on:input={updateSuggestions}
        on:keydown={handleKeydown}
        placeholder={isGenerating ? 'Generating...' : 'Enter prompt or /help'}
        disabled={isGenerating}
        spellcheck="false"
        autocomplete="off"
      />
    </div>

    {#if showSuggestions}
      <div class="suggestions">
        {#each suggestions as suggestion, i}
          <button
            class="suggestion"
            class:selected={i === selectedSuggestion}
            on:click={() => applySuggestion(suggestion)}
          >
            {suggestion}
          </button>
        {/each}
      </div>
    {/if}
  </div>
</div>

<style>
  .cli {
    height: 100%;
    display: flex;
    flex-direction: column;
    font-family: var(--font-mono);
    /* font-size is set via inline style from settings */
  }

  .history {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .line {
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.5;
  }

  .line.input {
    color: var(--accent-secondary);
  }

  .line.output {
    color: var(--success);
  }

  .line.error {
    color: var(--error);
  }

  .line.info {
    color: var(--text-secondary);
  }

  .line.success {
    color: #4ade80;
    font-weight: 500;
  }

  .line.dim {
    color: var(--text-muted);
    font-size: 12px;
  }

  .line.cyan {
    color: #22d3ee;
    font-weight: 600;
  }

  .line.magenta {
    color: #e879f9;
  }

  .line.header {
    color: #f97316;
    font-size: 16px;
    font-weight: 700;
    padding: 8px 0 4px 0;
  }

  .divider {
    height: 1px;
    background: linear-gradient(90deg, var(--border-color), transparent);
    margin: 8px 0;
  }

  .cmd-table {
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    overflow: hidden;
    margin: 8px 0;
  }

  .cmd-row {
    display: flex;
    padding: 6px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    transition: background 0.15s;
  }

  .cmd-row:last-child {
    border-bottom: none;
  }

  .cmd-row:hover {
    background: rgba(255, 255, 255, 0.03);
  }

  .cmd-name {
    color: #a78bfa;
    font-weight: 600;
    min-width: 160px;
    flex-shrink: 0;
  }

  .cmd-desc {
    color: var(--text-secondary);
  }

  .vars-table {
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    overflow: hidden;
    margin: 8px 0;
    max-height: 300px;
    overflow-y: auto;
  }

  .var-row {
    display: flex;
    padding: 4px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    gap: 12px;
    align-items: baseline;
  }

  .var-row:last-child {
    border-bottom: none;
  }

  .var-row:hover {
    background: rgba(255, 255, 255, 0.03);
  }

  .var-id {
    color: #e879f9;
    font-weight: 600;
    min-width: 200px;
    flex-shrink: 0;
  }

  .var-count {
    color: var(--text-muted);
    font-size: 11px;
    min-width: 40px;
  }

  .var-sample {
    color: var(--text-secondary);
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Active progress bar - fixed above input */
  .active-progress {
    flex-shrink: 0;
    border-top: 1px solid var(--border-color);
    background: var(--bg-secondary);
  }

  .active-progress .progress-container {
    margin: 0;
    border: none;
    border-radius: 0;
  }

  .input-area {
    position: relative;
    border-top: 1px solid var(--border-color);
    background: var(--bg-tertiary);
  }

  .input-line {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
  }

  .prompt-symbol {
    color: var(--accent-primary);
    font-weight: 600;
    font-size: 14px;
  }

  input {
    flex: 1;
    background: none;
    border: none;
    outline: none;
    color: var(--text-primary);
    font-family: inherit;
    font-size: inherit;
    caret-color: var(--accent-primary);
  }

  input::placeholder {
    color: var(--text-muted);
  }

  input:disabled {
    opacity: 0.5;
  }

  .suggestions {
    position: absolute;
    bottom: 100%;
    left: 16px;
    right: 16px;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    max-height: 200px;
    overflow-y: auto;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
  }

  .suggestion {
    display: block;
    width: 100%;
    padding: 8px 12px;
    text-align: left;
    background: none;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-mono);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.1s;
  }

  .suggestion:hover,
  .suggestion.selected {
    background: var(--accent-glow);
    color: var(--text-primary);
  }

  /* Progress Bar Styles */
  .progress-container {
    margin: 12px 0;
    padding: 12px 16px;
    background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(168, 85, 247, 0.05));
    border: 1px solid rgba(124, 58, 237, 0.3);
    border-radius: 8px;
  }

  .progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .progress-stage {
    color: #a78bfa;
    font-weight: 600;
    font-size: 12px;
    text-transform: capitalize;
  }

  .progress-percent {
    color: #22d3ee;
    font-weight: 700;
    font-size: 14px;
    font-variant-numeric: tabular-nums;
  }

  .progress-track {
    height: 8px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    overflow: hidden;
    position: relative;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #7c3aed, #a855f7, #c084fc);
    border-radius: 4px;
    transition: width 0.3s ease-out;
    position: relative;
    overflow: hidden;
  }

  .progress-glow {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
      90deg,
      transparent,
      rgba(255, 255, 255, 0.4),
      transparent
    );
    animation: shimmer 1.5s infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  .line.progress-msg {
    color: #94a3b8;
    font-size: 11px;
    padding-left: 8px;
    border-left: 2px solid rgba(124, 58, 237, 0.3);
    margin-left: 4px;
    animation: fadeSlideIn 0.2s ease-out;
  }

  /* Highlighted prompt styles - these should POP! */
  .prompt-highlight {
    margin: 8px 0;
    padding: 12px;
    border-radius: 8px;
    animation: promptPop 0.3s ease-out;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
  }

  .prompt-highlight.enhanced {
    background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(245, 158, 11, 0.1) 100%);
    border: 1px solid rgba(251, 191, 36, 0.4);
    box-shadow: 0 0 20px rgba(251, 191, 36, 0.1), inset 0 1px 0 rgba(251, 191, 36, 0.2);
  }

  .prompt-highlight.final {
    background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(16, 185, 129, 0.1) 100%);
    border: 1px solid rgba(34, 197, 94, 0.4);
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.1), inset 0 1px 0 rgba(34, 197, 94, 0.2);
  }

  .prompt-label {
    display: block;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 6px;
  }

  .prompt-highlight.enhanced .prompt-label {
    color: #fbbf24;
  }

  .prompt-highlight.final .prompt-label {
    color: #22c55e;
  }

  .prompt-text {
    color: #f8fafc;
    font-size: 13px;
    line-height: 1.6;
    word-wrap: break-word;
    white-space: pre-wrap;
  }

  @keyframes promptPop {
    0% {
      opacity: 0;
      transform: translateY(-10px) scale(0.98);
    }
    50% {
      transform: translateY(2px) scale(1.01);
    }
    100% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  @keyframes fadeSlideIn {
    from {
      opacity: 0;
      transform: translateX(-10px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Shared toggle icon for Tips and Tutorial */
  .toggle-icon {
    font-size: 10px;
    color: var(--text-muted);
    transition: transform 0.2s;
  }

  /* Collapsible Tutorial Section */
  .tutorial-section {
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .tutorial-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    color: #a78bfa;
    font-family: var(--font-mono);
    font-size: inherit;
    font-weight: 600;
    cursor: pointer;
    padding: 4px 0;
    transition: color 0.15s;
  }

  .tutorial-toggle:hover {
    color: #c4b5fd;
  }

  .tutorial-label {
    color: inherit;
  }

  .tutorial-content {
    margin-top: 4px;
    padding-left: 18px;
    animation: fadeIn 0.2s ease-out;
  }

  /* Collapsible Tips Section */
  .tips-section {
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .tips-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    color: #22d3ee;
    font-family: var(--font-mono);
    font-size: inherit;
    font-weight: 600;
    cursor: pointer;
    padding: 4px 0;
    transition: color 0.15s;
  }

  .tips-toggle:hover {
    color: #67e8f9;
  }

  .tips-label {
    color: inherit;
  }

  .tips-content {
    margin-top: 4px;
    padding-left: 18px;
    animation: fadeIn 0.2s ease-out;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
</style>



